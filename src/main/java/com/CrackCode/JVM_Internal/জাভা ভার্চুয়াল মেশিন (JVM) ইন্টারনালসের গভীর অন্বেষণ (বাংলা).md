# জাভা ভার্চুয়াল মেশিন (JVM) ইন্টারনালসের গভীর অন্বেষণ (বাংলা)



# জাভা ভার্চুয়াল মেশিন (JVM) ইন্টারনালসের গভীর অন্বেষণ

## ভূমিকা

জাভা ভার্চুয়াল মেশিন (JVM) জাভা প্ল্যাটফর্মের ভিত্তি হিসাবে দাঁড়িয়ে আছে, যা রানটাইম ইঞ্জিন হিসাবে জাভা অ্যাপ্লিকেশনগুলি চালায়। এটি জাভা কোডের মধ্যে `main` মেথড কল করার জন্য দায়ী সত্তা, যা প্রোগ্রামের এক্সিকিউশন শুরু করে। জাভা রানটাইম এনভায়রনমেন্ট (JRE)-এর একটি অবিচ্ছেদ্য অংশ হিসাবে, JVM "একবার লিখুন, যেকোনো জায়গায় চালান" (Write Once, Run Anywhere - WORA) নীতিকে মূর্ত করে। এই শক্তিশালী ধারণাটি ডেভেলপারদের একটি সিস্টেমে জাভা কোড লেখার সুযোগ দেয় এই আত্মবিশ্বাসের সাথে যে এটি অন্য যেকোনো সামঞ্জস্যপূর্ণ JVM যুক্ত সিস্টেমে নির্বিঘ্নে চলতে পারে, প্ল্যাটফর্ম-নির্দিষ্ট সমন্বয়ের প্রয়োজনীয়তা দূর করে। এই ক্রস-প্ল্যাটফর্ম সামঞ্জস্যতা JVM-এর অত্যাধুনিক আর্কিটেকচারের মাধ্যমে অর্জিত হয়, যা অন্তর্নিহিত হার্ডওয়্যার এবং অপারেটিং সিস্টেমের বিবরণকে বিমূর্ত করে। সোর্স কোড থেকে এক্সিকিউশনের যাত্রা শুরু হয় যখন একটি জাভা কম্পাইলার মানুষের পাঠযোগ্য `.java` ফাইলগুলিকে প্ল্যাটফর্ম-স্বাধীন `.class` ফাইলে রূপান্তরিত করে। এই ফাইলগুলিতে বাইটকোড থাকে, যা বিশেষভাবে JVM-এর জন্য ডিজাইন করা নির্দেশাবলীর একটি সেট। যখন একটি জাভা প্রোগ্রাম চালানো হয়, তখন JVM এই `.class` ফাইলগুলি নেয় এবং সেগুলিকে একাধিক সুনির্দিষ্ট ধাপের মাধ্যমে প্রক্রিয়া করে, যা সম্মিলিতভাবে JVM-এর অভ্যন্তরীণ কার্যকারিতা গঠন করে।

## ক্লাসলোডার সাবসিস্টেম

ক্লাসলোডার সাবসিস্টেম হল জাভা কোড এক্সিকিউশনের প্রবেশদ্বার, যা ক্লাস এবং ইন্টারফেসগুলির গতিশীল লোডিং, লিঙ্কিং এবং ইনিশিয়ালাইজেশনের গুরুত্বপূর্ণ দায়িত্বে নিয়োজিত। এই প্রক্রিয়াটি নিশ্চিত করে যে জাভা ক্লাসগুলি কেবল তখনই JVM-এ আনা হয় যখন তাদের প্রয়োজন হয়, যা প্ল্যাটফর্মের নমনীয়তা এবং দক্ষতায় অবদান রাখে। সাবসিস্টেমটি তিনটি স্বতন্ত্র পর্যায়ে তার দায়িত্ব পালন করে:

### ১. লোডিং

লোডিং পর্ব শুরু হয় যখন ক্লাসলোডার একটি `.class` ফাইল পড়ে। এটি ফাইলের মধ্যে থাকা বাইনারি ডেটা পার্স করে, ক্লাস বা ইন্টারফেস সম্পর্কে প্রয়োজনীয় তথ্য বের করে। এই তথ্যের মধ্যে ক্লাসের সম্পূর্ণ যোগ্য নাম (fully qualified name), এর তাৎক্ষণিক প্যারেন্ট ক্লাস, এটি ক্লাস, ইন্টারফেস নাকি এনাম প্রতিনিধিত্ব করে এবং এর মডিফায়ার, ভেরিয়েবল এবং মেথড সম্পর্কিত বিবরণ অন্তর্ভুক্ত থাকে, যা পরে JVM-এর মধ্যে মেথড এরিয়া নামক একটি ডেডিকেটেড মেমরি অঞ্চলে সংরক্ষণ করা হয়। প্রতিটি সফলভাবে লোড হওয়া `.class` ফাইলের জন্য, JVM হিপ মেমরিতে `java.lang.Class` অবজেক্টের একটি ইনস্ট্যান্সও তৈরি করে। এই `Class` অবজেক্টটি লোড হওয়া ক্লাসের রানটাইম উপস্থাপনা হিসাবে কাজ করে, এর মেটাডেটাতে প্রোগ্রাম্যাটিক অ্যাক্সেস প্রদান করে, যেমন এর নাম, প্যারেন্ট, ফিল্ড এবং মেথড, যা প্রায়শই `java.lang.Object` থেকে উত্তরাধিকার সূত্রে প্রাপ্ত `getClass()` মেথডের মাধ্যমে রিফ্লেকশন ব্যবহার করে কাজে লাগানো হয়। এটি মনে রাখা গুরুত্বপূর্ণ যে JVM নিশ্চিত করে যে প্রতি লোড হওয়া ক্লাসের জন্য কেবল একটি `Class` অবজেক্ট তৈরি হয়, তা যতবারই রেফারেন্স বা ইনস্ট্যানশিয়েট করা হোক না কেন।

এই প্রক্রিয়ায় সাধারণত তিনটি প্রধান ক্লাসলোডার জড়িত থাকে, যা একটি ডেলিগেশন হায়ারার্কির অধীনে কাজ করে:

*   **বুটস্ট্র্যাপ ক্লাস লোডার (Bootstrap Class Loader):** এটি হল আদিম ক্লাসলোডার, প্রতিটি JVM বাস্তবায়নের অবিচ্ছেদ্য অংশ। এটি `JAVA_HOME/lib` ডিরেক্টরিতে (প্রায়শই বুটস্ট্র্যাপ পাথ হিসাবে পরিচিত) থাকা মূল জাভা API ক্লাসগুলি লোড করার জন্য দায়ী। এর মৌলিক ভূমিকা এবং নেটিভ অপারেটিং সিস্টেমের সাথে ঘনিষ্ঠ মিথস্ক্রিয়ার প্রয়োজনের কারণে, এটি সাধারণত জাভার পরিবর্তে নেটিভ কোডে (যেমন C বা C++) প্রয়োগ করা হয়।
*   **এক্সটেনশন ক্লাস লোডার (Extension Class Loader):** বুটস্ট্র্যাপ ক্লাস লোডারের একটি চাইল্ড হিসাবে কাজ করে, এই লোডারটি জাভা এক্সটেনশন ডিরেক্টরিতে থাকা ক্লাসগুলি পরিচালনা করে, সাধারণত `JAVA_HOME/jre/lib/ext`, অথবা `java.ext.dirs` সিস্টেম প্রপার্টি দ্বারা নির্দিষ্ট করা অন্যান্য ডিরেক্টরি। এটি জাভাতে প্রয়োগ করা হয়, বিশেষত অনেক স্ট্যান্ডার্ড JVM বাস্তবায়নে `sun.misc.Launcher$ExtClassLoader` ক্লাস দ্বারা।
*   **সিস্টেম/অ্যাপ্লিকেশন ক্লাস লোডার (System/Application Class Loader):** এক্সটেনশন ক্লাস লোডারের একটি চাইল্ড হিসাবে, এটি স্ট্যান্ডার্ড হায়ারার্কির চূড়ান্ত লোডার। এর প্রাথমিক কাজ হল অ্যাপ্লিকেশন ক্লাসপাথে পাওয়া অ্যাপ্লিকেশন-নির্দিষ্ট ক্লাসগুলি লোড করা, যা সাধারণত `CLASSPATH` এনভায়রনমেন্ট ভেরিয়েবল বা `-cp` কমান্ড-লাইন অপশন দ্বারা সংজ্ঞায়িত করা হয়। এক্সটেনশন ক্লাস লোডারের মতো, এটিও জাভাতে প্রয়োগ করা হয়, সাধারণত `sun.misc.Launcher$AppClassLoader` ক্লাস দ্বারা।

JVM ক্লাস লোড করার জন্য একটি **ডেলিগেশন-হায়ারার্কি নীতি (Delegation-Hierarchy Principle)** ব্যবহার করে। যখন একটি ক্লাস লোড করার অনুরোধ করা হয় (যেমন, সিস্টেম ক্লাস লোডারের কাছে), এটি প্রথমে অনুরোধটি হায়ারার্কির উপরে তার প্যারেন্টের (এক্সটেনশন ক্লাস লোডার) কাছে অর্পণ করে। এক্সটেনশন ক্লাস লোডার, পালাক্রমে, তার প্যারেন্টের (বুটস্ট্র্যাপ ক্লাস লোডার) কাছে অর্পণ করে। বুটস্ট্র্যাপ ক্লাস লোডার প্রথমে ক্লাসটি লোড করার চেষ্টা করে। যদি এটি ক্লাসটি খুঁজে পায় এবং লোড করে (কারণ এটি একটি কোর API ক্লাস), প্রক্রিয়াটি থেমে যায়। যদি না হয়, অনুরোধটি এক্সটেনশন ক্লাস লোডারের কাছে ফিরে আসে, যা এক্সটেনশন ডিরেক্টরি থেকে এটি লোড করার চেষ্টা করে। যদি এটি ব্যর্থ হয়, অনুরোধটি অবশেষে সিস্টেম/অ্যাপ্লিকেশন ক্লাস লোডারের কাছে ফিরে আসে, যা অ্যাপ্লিকেশন ক্লাসপাথ অনুসন্ধান করে। যদি এই সমস্ত অবস্থান অনুসন্ধান করার পরেও ক্লাসটি খুঁজে না পাওয়া যায়, JVM একটি `java.lang.ClassNotFoundException` থ্রো করে।

### ২. লিঙ্কিং

সফল লোডিংয়ের পরে, ক্লাসটি লিঙ্কিং পর্যায়ে প্রবেশ করে, যার মধ্যে নতুন লোড হওয়া টাইপটিকে JVM-এর রানটাইম স্টেটে একীভূত করা জড়িত। লিঙ্কিং নিজেই তিনটি উপ-ধাপ নিয়ে গঠিত:

*   **ভেরিফিকেশন (Verification):** এটি একটি গুরুত্বপূর্ণ নিরাপত্তা পদক্ষেপ যেখানে JVM নিশ্চিত করে যে ক্লাসের লোড হওয়া বাইনারি উপস্থাপনা কাঠামোগতভাবে সঠিক, JVM স্পেসিফিকেশন মেনে চলে এবং একটি বৈধ কম্পাইলার দ্বারা তৈরি করা হয়েছে। বাইটকোড ভেরিফায়ার কম্পোনেন্ট সঠিক ফরম্যাটিং, বৈধ ইন্সট্রাকশন, সঠিক অপারেন্ড স্ট্যাক ব্যবহার এবং অ্যাক্সেস কন্ট্রোল নিয়ম মেনে চলার মতো পরীক্ষাগুলি সম্পাদন করে। যদি ত্রুটিপূর্ণ বা দূষিত বাইটকোডের কারণে ভেরিফিকেশন ব্যর্থ হয়, একটি `java.lang.VerifyError` থ্রো করা হয়, যা সম্ভাব্য ক্ষতিকারক কোড এক্সিকিউট হওয়া থেকে বাধা দেয়।
*   **প্রস্তুতি (Preparation):** এই ধাপে, JVM ক্লাসের স্ট্যাটিক ভেরিয়েবলগুলির (ক্লাস ভেরিয়েবল হিসাবেও পরিচিত) জন্য মেমরি বরাদ্দ করে এবং সেগুলিকে তাদের টাইপ অনুযায়ী ডিফল্ট মান দিয়ে ইনিশিয়ালাইজ করে (যেমন, সাংখ্যিক প্রকারের জন্য 0, বুলিয়ানের জন্য `false`, রেফারেন্স প্রকারের জন্য `null`)। মনে রাখবেন যে এটি কেবল ডিফল্ট ইনিশিয়ালাইজেশন; সোর্স কোডে সংজ্ঞায়িত প্রকৃত প্রাথমিক মানগুলি ইনিশিয়ালাইজেশন পর্যায়ে নির্ধারিত হয়।
*   **রেজোলিউশন (Resolution) (ঐচ্ছিক):** রেজোলিউশন হল ক্লাসের রানটাইম কনস্ট্যান্ট পুলের মধ্যে থাকা সিম্বলিক রেফারেন্সগুলিকে ডাইরেক্ট রেফারেন্সে রূপান্তরিত করার প্রক্রিয়া। সিম্বলিক রেফারেন্স হল বাইটকোডে ব্যবহৃত লজিক্যাল রেফারেন্স (যেমন, একটি ক্লাস বা মেথডের নাম), যেখানে ডাইরেক্ট রেফারেন্স হল সাধারণত মেমরি অ্যাড্রেস বা অফসেট যা JVM-কে সরাসরি উল্লেখিত সত্তা অ্যাক্সেস করতে দেয়। এই ধাপে মেথড এরিয়া অনুসন্ধান করে উল্লেখিত ক্লাস, ফিল্ড এবং মেথডগুলি সনাক্ত করা জড়িত। যদিও JVM স্পেসিফিকেশন এই পর্যায়ে রেজোলিউশন হওয়ার অনুমতি দেয়, অনেক বাস্তবায়ন এটিকে অলসভাবে সম্পাদন করে, সিম্বলিক রেফারেন্সগুলি কেবল তখনই সমাধান করে যখন সেগুলি এক্সিকিউশনের সময় প্রথমবার ব্যবহার করা হয়।

### ৩. ইনিশিয়ালাইজেশন

ক্লাসলোডার সাবসিস্টেমের চূড়ান্ত পর্যায় হল ইনিশিয়ালাইজেশন। এই পর্যায়ে, JVM ক্লাসের ইনিশিয়ালাইজেশন লজিক এক্সিকিউট করে। এর মধ্যে স্ট্যাটিক ভেরিয়েবলগুলিতে প্রকৃত প্রাথমিক মানগুলি (সোর্স কোডে সংজ্ঞায়িত) নির্ধারণ করা এবং যেকোনো স্ট্যাটিক ইনিশিয়ালাইজেশন ব্লক (`static {}` ব্লক) এক্সিকিউট করা জড়িত। ইনিশিয়ালাইজেশন প্রক্রিয়া একটি নির্দিষ্ট ক্রমে ঘটে: ক্লাস সংজ্ঞার মধ্যে উপর থেকে নীচে, এবং গুরুত্বপূর্ণভাবে, সুপারক্লাস তার সাবক্লাসের আগে ইনিশিয়ালাইজড হয়। ইনিশিয়ালাইজেশন কেবল তখনই ট্রিগার হয় যখন একটি ক্লাস প্রথমবারের মতো সক্রিয়ভাবে ব্যবহার করা হয়, যেমন যখন একটি ইনস্ট্যান্স তৈরি করা হয়, একটি স্ট্যাটিক মেথড কল করা হয়, বা একটি স্ট্যাটিক ফিল্ড অ্যাক্সেস করা হয় (যদি না এটি একটি কম্পাইল-টাইম কনস্ট্যান্ট হয়)। JVM নিশ্চিত করে যে ইনিশিয়ালাইজেশন থ্রেড-সেফ, যার অর্থ একটি ক্লাস কেবল একবারই ইনিশিয়ালাইজড হয়, এমনকি মাল্টিথ্রেডেড পরিবেশে।




## JVM রানটাইম ডেটা এরিয়া

ক্লাসগুলি লোড, লিঙ্ক এবং ইনিশিয়ালাইজড হওয়ার পরে, প্রোগ্রামটির এক্সিকিউশন পরিচালনা করার জন্য JVM-এর নির্দিষ্ট মেমরি অঞ্চলের প্রয়োজন হয়। এই অঞ্চলগুলি, সম্মিলিতভাবে রানটাইম ডেটা এরিয়া হিসাবে পরিচিত, JVM স্পেসিফিকেশন দ্বারা সংজ্ঞায়িত এবং প্রোগ্রাম এক্সিকিউশনের সময় ডেটা সংরক্ষণের জন্য অপরিহার্য। এই অঞ্চলগুলির মধ্যে কিছু JVM শুরু হওয়ার সময় তৈরি হয় এবং এটি বন্ধ হওয়ার পরেই ধ্বংস হয়, অন্যরা প্রতি-থ্রেড ভিত্তিতে তৈরি এবং ধ্বংস হয়। জাভা কীভাবে মেমরি পরিচালনা করে এবং কোড এক্সিকিউট করে তা বোঝার জন্য এই অঞ্চলগুলি অত্যন্ত গুরুত্বপূর্ণ।

### ১. মেথড এরিয়া (Method Area)

মেথড এরিয়া হল JVM-এর মধ্যে সমস্ত থ্রেডের মধ্যে শেয়ার করা একটি মৌলিক মেমরি অঞ্চল। এটি JVM স্টার্টআপের সময় তৈরি হয় এবং প্রাথমিকভাবে প্রতি-ক্লাস স্ট্রাকচার সংরক্ষণের জন্য কাজ করে। এর মধ্যে রানটাইম কনস্ট্যান্ট পুল (কনস্ট্যান্ট এবং সিম্বলিক রেফারেন্স ধারণকারী), ফিল্ড এবং মেথড ডেটা (একটি ক্লাসের মধ্যে ভেরিয়েবল এবং মেথড সম্পর্কিত তথ্য), এবং মেথড ও কনস্ট্রাক্টরগুলির জন্য প্রকৃত বাইটকোড অন্তর্ভুক্ত থাকে, যার মধ্যে ক্লাস ইনিশিয়ালাইজার (`<clinit>`) এর মতো বিশেষ মেথডও রয়েছে। ক্লাসের সাথে যুক্ত স্ট্যাটিক ভেরিয়েবলগুলিও এখানে সংরক্ষণ করা হয়। যদিও মেথড এরিয়া যৌক্তিকভাবে হিপের অংশ হিসাবে বিবেচিত হয়, JVM স্পেসিফিকেশন একটি নির্দিষ্ট অবস্থান বা পরিচালনা নীতি বাধ্যতামূলক করে না। বাস্তবায়নগুলি বিভিন্ন কৌশল বেছে নিতে পারে, যেমন এই অঞ্চলে গার্বেজ কালেকশন বা কম্প্যাকশন না করা, বা এটিকে প্রধান গার্বেজ-কালেক্টেড হিপের বাইরে রাখা। মেথড এরিয়ার আকার স্থির বা অ্যাপ্লিকেশনের প্রয়োজনের ভিত্তিতে গতিশীলভাবে সামঞ্জস্য করা যেতে পারে। যদি JVM একটি অনুরোধ সন্তুষ্ট করার জন্য মেথড এরিয়ার মধ্যে পর্যাপ্ত মেমরি বরাদ্দ করতে না পারে (যেমন, একটি নতুন ক্লাস লোড করা বা তার রানটাইম কনস্ট্যান্ট পুল তৈরি করা), এটি একটি `OutOfMemoryError` থ্রো করবে।

### ২. হিপ এরিয়া (Heap Area)

হিপ এরিয়া সম্ভবত সবচেয়ে পরিচিত রানটাইম ডেটা এরিয়া, যা সমস্ত JVM থ্রেডের মধ্যে শেয়ার করা হয় এবং JVM স্টার্টআপে তৈরি হয়। এটি সেই প্রাথমিক অঞ্চল যেখান থেকে প্রোগ্রাম এক্সিকিউশনের সময় সমস্ত ক্লাস ইনস্ট্যান্স (অবজেক্ট) এবং অ্যারেগুলির জন্য মেমরি বরাদ্দ করা হয়। যখনই আপনি একটি অবজেক্ট তৈরি করতে বা একটি অ্যারে ইনস্ট্যানশিয়েট করতে `new` কীওয়ার্ড ব্যবহার করেন, সেই সত্তার জন্য মেমরি হিপে বরাদ্দ করা হয়। হিপের ব্যবস্থাপনা সাধারণত একটি স্বয়ংক্রিয় স্টোরেজ ম্যানেজমেন্ট সিস্টেম দ্বারা পরিচালিত হয়, যা সাধারণত গার্বেজ কালেক্টর (GC) নামে পরিচিত। GC-এর ভূমিকা হল স্বয়ংক্রিয়ভাবে সেই অবজেক্টগুলি সনাক্ত করা এবং তাদের দখল করা মেমরি পুনরুদ্ধার করা যা চলমান অ্যাপ্লিকেশন দ্বারা আর রেফারেন্স করা হয় না, মেমরি লিক প্রতিরোধ করা এবং ডেভেলপারদের জন্য মেমরি ব্যবস্থাপনা সহজ করা। মেথড এরিয়ার মতো, হিপের আকার স্থির বা JVM বাস্তবায়ন দ্বারা গতিশীলভাবে পরিচালিত (প্রসারিত বা সংকুচিত) হতে পারে। হিপের মধ্যে মেমরি অবিচ্ছিন্ন হওয়ার প্রয়োজন নেই। যদি একটি অ্যাপ্লিকেশন হিপে মেমরি বরাদ্দ করার চেষ্টা করে (যেমন, একটি বড় অবজেক্ট বা অ্যারে তৈরি করা) এবং প্রয়োজনীয় স্থান উপলব্ধ করা না যায়, এমনকি গার্বেজ কালেকশনের প্রচেষ্টার পরেও, JVM একটি `OutOfMemoryError` থ্রো করবে।

### ৩. স্ট্যাক এরিয়া (JVM Stacks)

মেথড এরিয়া এবং হিপের বিপরীতে, JVM স্ট্যাক প্রতিটি থ্রেডের জন্য ব্যক্তিগত। একটি থ্রেড তার এক্সিকিউশন শুরু করার মুহূর্তে একটি নতুন JVM স্ট্যাক তৈরি হয়। স্ট্যাকের প্রাথমিক উদ্দেশ্য হল ফ্রেম সংরক্ষণ করা। প্রতিটি ফ্রেম একটি একক মেথড ইনভোকেশনের সাথে সঙ্গতিপূর্ণ। যখন একটি মেথড কল করা হয়, তখন এক্সিকিউটিং থ্রেডের সাথে যুক্ত স্ট্যাকের উপর একটি নতুন ফ্রেম পুশ করা হয়; যখন মেথডটি সম্পন্ন হয় (হয় স্বাভাবিকভাবে রিটার্ন করে বা একটি আনহ্যান্ডেলড এক্সেপশন থ্রো করে), তার সংশ্লিষ্ট ফ্রেমটি স্ট্যাক থেকে পপ করা হয়। প্রতিটি ফ্রেমে মেথডের লোকাল ভেরিয়েবল, মধ্যবর্তী গণনার জন্য একটি অপারেন্ড স্ট্যাক এবং ডাইনামিক লিঙ্কিং ও মেথড রিটার্ন মান সমর্থন করার জন্য ডেটা থাকে। JVM স্ট্যাকগুলি প্রচলিত ভাষা যেমন C বা C++ এ পাওয়া কল স্ট্যাকগুলির অনুরূপ। ফ্রেমগুলির জন্য মেমরি স্ট্যাক নিজেই থেকে বরাদ্দ করা যেতে পারে, বা কিছু বাস্তবায়নে সম্ভাব্যভাবে হিপ থেকে, এবং স্ট্যাক মেমরি অবিচ্ছিন্ন হওয়ার প্রয়োজন নেই। JVM স্ট্যাকগুলির একটি নির্দিষ্ট আকার থাকতে পারে বা গণনার সময় প্রয়োজন অনুযায়ী গতিশীলভাবে প্রসারিত হতে পারে। তবে, এর সীমা রয়েছে। যদি একটি থ্রেডের গণনার জন্য অনুমোদিত আকারের চেয়ে বড় স্ট্যাকের প্রয়োজন হয় (হয় গভীর রিকার্শন বা বড় ফ্রেমের কারণে), একটি `StackOverflowError` থ্রো করা হয়। যদি স্ট্যাকটি ডাইনামিক সম্প্রসারণের জন্য কনফিগার করা থাকে এবং অপর্যাপ্ত মেমরির কারণে একটি সম্প্রসারণের চেষ্টা ব্যর্থ হয়, একটি `OutOfMemoryError` থ্রো করা হয়।

### ৪. পিসি রেজিস্টার (Program Counter Registers)

JVM-এর মধ্যে প্রতিটি থ্রেডের নিজস্ব প্রোগ্রাম কাউন্টার (PC) রেজিস্টারও রয়েছে। PC রেজিস্টার তুলনামূলকভাবে ছোট এবং সেই থ্রেড দ্বারা বর্তমানে এক্সিকিউট হওয়া জাভা ভার্চুয়াল মেশিন ইন্সট্রাকশনের ঠিকানা ধারণ করে। যেহেতু জাভা মেথডগুলি একাধিক থ্রেড দ্বারা একই সাথে এক্সিকিউট হতে পারে, প্রতিটি থ্রেডের তার স্বাধীন এক্সিকিউশন পয়েন্টের ট্র্যাক রাখার জন্য নিজস্ব PC রেজিস্টার প্রয়োজন। যদি থ্রেড দ্বারা বর্তমানে এক্সিকিউট হওয়া মেথডটি একটি `native` মেথড হয় (অর্থাৎ, জাভা ছাড়া অন্য কোনো ভাষায় প্রয়োগ করা, যেমন C বা C++), PC রেজিস্টারের মান অনির্ধারিত থাকে, কারণ এক্সিকিউশনটি JVM-এর ইন্সট্রাকশন সেটের সরাসরি নিয়ন্ত্রণের বাইরে। PC রেজিস্টার সাধারণত নির্দিষ্ট প্ল্যাটফর্মে একটি `returnAddress` বা একটি নেটিভ পয়েন্টার সংরক্ষণ করার জন্য যথেষ্ট প্রশস্ত হয়।

### ৫. নেটিভ মেথড স্ট্যাক (Native Method Stacks)

জাভা বাইটকোড এক্সিকিউট করার জন্য ব্যবহৃত JVM স্ট্যাকগুলি ছাড়াও, JVM প্রায়শই `native` মেথডগুলির এক্সিকিউশন সমর্থন করার জন্য পৃথক নেটিভ মেথড স্ট্যাক ব্যবহার করে। JVM স্ট্যাকগুলির মতো, একটি নেটিভ মেথড স্ট্যাক সাধারণত প্রতি থ্রেডে বরাদ্দ করা হয়। যখন একটি থ্রেড একটি নেটিভ মেথড কল করে, তখন এটি প্রায়শই JVM স্ট্যাক থেকে একটি সংশ্লিষ্ট নেটিভ মেথড স্ট্যাকে স্থানান্তরিত হয়, যা নেটিভ ভাষার নিয়ম অনুযায়ী কাজ করে (প্রায়শই একটি C স্ট্যাকের মতো)। এই স্ট্যাকগুলি নেটিভ মেথড এক্সিকিউশনের জন্য প্রয়োজনীয় স্টেট সংরক্ষণ করে। JVM স্ট্যাকগুলির মতো, নেটিভ মেথড স্ট্যাকগুলি নির্দিষ্ট আকারের বা গতিশীলভাবে প্রসারণযোগ্য হতে পারে। যদি একটি থ্রেডের তার নেটিভ মেথড স্ট্যাকে উপলব্ধ স্থানের চেয়ে বেশি স্থানের প্রয়োজন হয়, একটি `StackOverflowError` (বা একটি অনুরূপ প্ল্যাটফর্ম-নির্দিষ্ট ত্রুটি) থ্রো হতে পারে। যদি ডাইনামিক সম্প্রসারণের চেষ্টা করা হয় কিন্তু মেমরির অভাবের কারণে ব্যর্থ হয়, একটি `OutOfMemoryError` ঘটে।

*(উৎস: GeeksforGeeks JVM Architecture আর্টিকেল এবং Oracle Java SE 7 JVM Specification, Chapter 2 থেকে প্রাপ্ত তথ্যের উপর ভিত্তি করে)*




## এক্সিকিউশন ইঞ্জিন (Execution Engine)

এক্সিকিউশন ইঞ্জিন হল JVM-এর হৃৎপিণ্ড, যা লোড হওয়া `.class` ফাইলগুলিতে থাকা বাইটকোডকে প্রকৃতপক্ষে এক্সিকিউট করার জন্য দায়ী। এটি বাইটকোড নির্দেশাবলী একের পর এক পড়ে, বিভিন্ন রানটাইম ডেটা এরিয়াতে (যেমন হিপ এবং স্ট্যাক) সংরক্ষিত ডেটা অ্যাক্সেস করে এবং কোড দ্বারা সংজ্ঞায়িত গণনাগুলি সম্পাদন করে। এক্সিকিউশন ইঞ্জিন একটি জটিল উপাদান, এবং এর অভ্যন্তরীণ কার্যকারিতা জাভা অ্যাপ্লিকেশনগুলির পারফরম্যান্সকে উল্লেখযোগ্যভাবে প্রভাবিত করে। এক্সিকিউশন ইঞ্জিনের মূল অংশগুলির মধ্যে রয়েছে ইন্টারপ্রেটার, জাস্ট-ইন-টাইম (JIT) কম্পাইলার এবং গার্বেজ কালেক্টর (GC)।

### ১. ইন্টারপ্রেটার (Interpreter)

বাইটকোড এক্সিকিউট করার সবচেয়ে সহজ উপায় হল ইন্টারপ্রিটেশন। ইন্টারপ্রেটার বাইটকোড স্ট্রিম ইন্সট্রাকশন ধরে ধরে পড়ে, প্রতিটি ইন্সট্রাকশনের অর্থ বোঝে এবং অবিলম্বে সংশ্লিষ্ট অপারেশনটি এক্সিকিউট করে। এই প্রক্রিয়াটি সহজবোধ্য কিন্তু তুলনামূলকভাবে ধীর হতে পারে, বিশেষ করে কোডের সেই অংশগুলির জন্য যা বারবার এক্সিকিউট হয়, যেমন লুপের মধ্যে থাকা মেথডগুলি। প্রতিবার যখন একটি ঘন ঘন কল করা মেথড ইনভোক করা হয়, ইন্টারপ্রেটারকে আবার তার বাইটকোড পড়া এবং ইন্টারপ্রেট করার প্রক্রিয়ার মধ্য দিয়ে যেতে হয়, যা পারফরম্যান্স ওভারহেড তৈরি করে।

### ২. জাস্ট-ইন-টাইম (JIT) কম্পাইলার

শুধুমাত্র ইন্টারপ্রিটেশনের পারফরম্যান্স সীমাবদ্ধতা কাটিয়ে উঠতে, আধুনিক JVM গুলি একটি জাস্ট-ইন-টাইম (JIT) কম্পাইলার ব্যবহার করে। JIT কম্পাইলার পারফরম্যান্স উন্নত করতে ইন্টারপ্রেটারের পাশাপাশি কাজ করে। এর প্রাথমিক লক্ষ্য হল "হটস্পট" গুলি সনাক্ত করা – বাইটকোডের সেই অংশগুলি (সাধারণত মেথড বা লুপ) যা ঘন ঘন এক্সিকিউট হয়। এই হটস্পটগুলিকে বারবার ইন্টারপ্রেট করার পরিবর্তে, JIT কম্পাইলার সেগুলিকে সরাসরি নেটিভ মেশিন কোডে অনুবাদ করে, যা অন্তর্নিহিত হার্ডওয়্যার আর্কিটেকচারের জন্য অপ্টিমাইজ করা হয়। এই কম্পাইল করা নেটিভ কোডটি হোস্ট সিপিইউ দ্বারা সরাসরি এক্সিকিউট করা যেতে পারে, যার ফলে ইন্টারপ্রিটেশনের তুলনায় উল্লেখযোগ্যভাবে দ্রুত পারফরম্যান্স পাওয়া যায়। JVM প্রায়শই কোড এক্সিকিউশন নিরীক্ষণ করতে এবং কোন অংশগুলি কম্পাইল করার যোগ্য তা নির্ধারণ করতে প্রোফাইলিং কৌশল ব্যবহার করে। একবার একটি মেথড কম্পাইল হয়ে গেলে, সেটির পরবর্তী কলগুলি ইন্টারপ্রেট হওয়ার পরিবর্তে দ্রুততর নেটিভ সংস্করণটি এক্সিকিউট করবে। এই অভিযোজিত অপ্টিমাইজেশন কৌশলটি জাভা অ্যাপ্লিকেশনগুলিকে C++ এর মতো নেটিভলি কম্পাইল করা ভাষাগুলির কাছাকাছি পারফরম্যান্স স্তর অর্জন করতে দেয়।

### ৩. গার্বেজ কালেক্টর (GC)

যদিও সরাসরি অ্যাপ্লিকেশন বাইটকোড এক্সিকিউট করে না, গার্বেজ কালেক্টর এক্সিকিউশন ইঞ্জিনের একটি অত্যাবশ্যক উপাদান, যা হিপ এরিয়ার মধ্যে স্বয়ংক্রিয় মেমরি ব্যবস্থাপনার জন্য দায়ী। অবজেক্টগুলি তৈরি এবং ব্যবহার হওয়ার সাথে সাথে কিছু অবশেষে অপ্রাপ্য (unreachable) হয়ে যায় – যার অর্থ চলমান প্রোগ্রামের কোনও অংশ আর সেগুলির প্রতি রেফারেন্স ধরে রাখে না। এই অপ্রাপ্য অবজেক্টগুলি মেমরি দখল করে রাখে যা পুনরায় ব্যবহার করা যেতে পারে। GC পর্যায়ক্রমে হিপ স্ক্যান করে, এই অপ্রাপ্য অবজেক্টগুলি সনাক্ত করে এবং তাদের দখল করা মেমরি পুনরুদ্ধার করে, এটিকে ভবিষ্যতের বরাদ্দের জন্য উপলব্ধ করে। জাভা বিভিন্ন GC অ্যালগরিদম (যেমন, Serial, Parallel, CMS, G1, ZGC, Shenandoah) অফার করে, যার প্রত্যেকটির পজ টাইম (pause times), থ্রুপুট এবং মেমরি ওভারহেডের ক্ষেত্রে বিভিন্ন বৈশিষ্ট্য রয়েছে। GC-এর পছন্দ অ্যাপ্লিকেশন পারফরম্যান্স এবং প্রতিক্রিয়াশীলতাকে উল্লেখযোগ্যভাবে প্রভাবিত করতে পারে। GC স্বয়ংক্রিয়ভাবে ব্যাকগ্রাউন্ডে কাজ করে, ডেভেলপারদের ম্যানুয়াল মেমরি ডিঅ্যালোকেশনের বোঝা থেকে মুক্তি দেয়, যা স্বয়ংক্রিয় মেমরি ব্যবস্থাপনা ছাড়া ভাষাগুলিতে ত্রুটির একটি সাধারণ উৎস (যেমন মেমরি লিক বা ড্যাংলিং পয়েন্টার)।

## জাভা নেটিভ ইন্টারফেস (JNI)

জাভা নেটিভ ইন্টারফেস (JNI) JVM-এর ভিতরে চলমান জাভা কোড এবং অন্তর্নিহিত হার্ডওয়্যার ও অপারেটিং সিস্টেমের জন্য কম্পাইল করা নেটিভ অ্যাপ্লিকেশন বা লাইব্রেরিগুলির মধ্যে একটি সেতু হিসাবে কাজ করে। এটি জাভা কোডের জন্য অন্য ভাষায় (সাধারণত C, C++, বা অ্যাসেম্বলি) প্রয়োগ করা মেথড কল করার এবং নেটিভ কোডের জন্য JVM-এর সাথে ইন্টারঅ্যাক্ট করার (যেমন জাভা অবজেক্ট তৈরি করা, জাভা মেথড কল করা, বা জাভা ফিল্ড অ্যাক্সেস করা) একটি সুনির্দিষ্ট প্রক্রিয়া সরবরাহ করে। JNI অপরিহার্য যখন একটি জাভা অ্যাপ্লিকেশনের প্ল্যাটফর্ম-নির্দিষ্ট বৈশিষ্ট্যগুলি ব্যবহার করার প্রয়োজন হয় যা স্ট্যান্ডার্ড জাভা API-এর মাধ্যমে সরাসরি উপলব্ধ নয়, নেটিভ কোডে লেখা লিগ্যাসি সিস্টেমগুলির সাথে ইন্টারঅ্যাক্ট করতে হয়, বা নেটিভলি প্রয়োগ করা পারফরম্যান্স-ক্রিটিক্যাল লাইব্রেরিগুলি ব্যবহার করতে হয়। এক্সিকিউশন ইঞ্জিন যখন একটি `native` মেথডের ইনভোকেশন সম্মুখীন হয় তখন JNI ব্যবহার করে, যা জাভা এক্সিকিউশন এনভায়রনমেন্ট এবং নেটিভ কোড এক্সিকিউশনের মধ্যে স্থানান্তরকে সহজতর করে, প্রায়শই নেটিভ মেথড স্ট্যাকগুলি জড়িত থাকে।

## নেটিভ মেথড লাইব্রেরি

JNI-এর পরিপূরক হল নেটিভ মেথড লাইব্রেরি। এগুলি সাধারণত C বা C++ এ লেখা লাইব্রেরিগুলির সংগ্রহ যা জাভা কোডে ঘোষিত `native` মেথডগুলির জন্য প্রকৃত বাস্তবায়ন সরবরাহ করে। এই লাইব্রেরিগুলি অন্তর্নিহিত প্ল্যাটফর্মের (হার্ডওয়্যার এবং অপারেটিং সিস্টেম) জন্য নির্দিষ্ট। যখন এক্সিকিউশন ইঞ্জিন, JNI-এর মাধ্যমে, একটি নেটিভ মেথড এক্সিকিউট করার প্রয়োজন হয়, তখন এটি উপযুক্ত নেটিভ মেথড লাইব্রেরি সনাক্ত করে এবং লোড করে এবং সেই লাইব্রেরির মধ্যে সংশ্লিষ্ট নেটিভ ফাংশনটি কল করে। মূল জাভা API নিজেই অপারেটিং সিস্টেম বা হার্ডওয়্যারের সাথে ইন্টারঅ্যাকশন প্রয়োজন এমন কাজগুলির জন্য নেটিভ মেথড লাইব্রেরিগুলির উপর ব্যাপকভাবে নির্ভর করে, যেমন ফাইল I/O, নেটওয়ার্কিং এবং গ্রাফিক্যাল ইউজার ইন্টারফেস রেন্ডারিংয়ের নির্দিষ্ট দিকগুলি।

*(উৎস: GeeksforGeeks JVM Architecture আর্টিকেল এবং Oracle Java SE 7 JVM Specification, Chapter 2 থেকে প্রাপ্ত তথ্যের উপর ভিত্তি করে)*


## উপসংহার

জাভা ভার্চুয়াল মেশিন একটি অত্যাধুনিক প্রকৌশল নিদর্শন, যা জাভা অ্যাপ্লিকেশনগুলির জন্য একটি প্ল্যাটফর্ম-স্বাধীন, সুরক্ষিত এবং উচ্চ-পারফরম্যান্স এক্সিকিউশন এনভায়রনমেন্ট সরবরাহ করার জন্য যত্ন সহকারে ডিজাইন করা হয়েছে। এর আর্কিটেকচার, যা ক্লাসলোডার, রানটাইম ডেটা এরিয়া (মেথড এরিয়া, হিপ, স্ট্যাকস, পিসি রেজিস্টার, নেটিভ মেথড স্ট্যাকস), এবং এক্সিকিউশন ইঞ্জিন (ইন্টারপ্রেটার, JIT কম্পাইলার, গার্বেজ কালেক্টর) এর মতো স্বতন্ত্র সাবসিস্টেম নিয়ে গঠিত, একটি জাভা প্রোগ্রামের সম্পূর্ণ জীবনচক্র পরিচালনা করতে একসাথে কাজ করে, বাইটকোড লোড করা থেকে শুরু করে এটিকে দক্ষতার সাথে এক্সিকিউট করা এবং স্বয়ংক্রিয়ভাবে মেমরি পরিচালনা করা পর্যন্ত। এই অভ্যন্তরীণ উপাদানগুলি এবং তাদের মিথস্ক্রিয়া বোঝা অপ্টিমাইজড, শক্তিশালী এবং স্কেলেবল অ্যাপ্লিকেশন লিখতে চাওয়া জাভা ডেভেলপারদের জন্য অত্যন্ত গুরুত্বপূর্ণ। অন্তর্নিহিত হার্ডওয়্যার এবং অপারেটিং সিস্টেমকে বিমূর্ত করে, JVM সত্যিই "একবার লিখুন, যেকোনো জায়গায় চালান" এর প্রতিশ্রুতি পূরণ করে, যা জাভাকে বিশ্বের অন্যতম বহুমুখী এবং বহুল ব্যবহৃত প্রোগ্রামিং ভাষাগুলির মধ্যে একটি করে তুলেছে।


